import { V1Ingress } from '@kubernetes/client-node';
import { IngressData } from '@/types/ingress';

/**
 * Filter out auto-generated annotations that shouldn't be displayed to users
 */
function filterAutoGeneratedAnnotations(annotations: Record<string, string> | undefined): Record<string, string> {
  if (!annotations) return {};
  
  const filtered: Record<string, string> = {};
  
  for (const [key, value] of Object.entries(annotations)) {
    // Skip common auto-generated annotations
    if (
      key.startsWith('kubectl.kubernetes.io/') ||
      key.startsWith('deployment.kubernetes.io/') ||
      key.startsWith('replicaset.kubernetes.io/') ||
      key.startsWith('statefulset.kubernetes.io/') ||
      key.startsWith('controller-uid') ||
      key.startsWith('meta.helm.sh/') ||
      key.startsWith('helm.sh/') ||
      key === 'kubernetes.io/ingress.class' // This is often auto-set
    ) {
      continue;
    }
    filtered[key] = value;
  }
  
  return filtered;
}

/**
 * Transform a raw Kubernetes Ingress object to our UI-friendly IngressData format
 */
export function transformIngress(k8sIngress: V1Ingress): IngressData {
  const metadata = k8sIngress.metadata || { name: 'unknown', namespace: 'default' };
  
  const hosts: string[] = [];
  const paths: string[] = [];
  const urls: string[] = [];
  
  // Extract hosts and paths from ingress rules
  if (k8sIngress.spec?.rules) {
    for (const rule of k8sIngress.spec.rules) {
      if (rule.host) {
        hosts.push(rule.host);
      }
      
      if (rule.http?.paths) {
        for (const path of rule.http.paths) {
          paths.push(path.path || '/');
          
          // Build URLs for the ingress
          if (rule.host) {
            const protocol = k8sIngress.spec?.tls ? 'https' : 'http';
            const pathValue = path.path || '/';
            urls.push(`${protocol}://${rule.host}${pathValue}`);
          }
        }
      }
    }
  }
  
  // Check for TLS configuration
  const hasTLS = !!(k8sIngress.spec?.tls && k8sIngress.spec.tls.length > 0);
  
  // Extract TLS hosts if available
  if (k8sIngress.spec?.tls) {
    for (const tls of k8sIngress.spec.tls) {
      if (tls.hosts) {
        for (const host of tls.hosts) {
          if (!hosts.includes(host)) {
            hosts.push(host);
          }
        }
      }
    }
  }
  
  return {
    id: metadata.uid || `${metadata.namespace}-${metadata.name}`,
    name: metadata.name || 'unknown',
    namespace: metadata.namespace || 'default',
    hosts,
    paths,
    urls,
    annotations: filterAutoGeneratedAnnotations(metadata.annotations),
    creationTimestamp: metadata.creationTimestamp
      ? typeof metadata.creationTimestamp === 'string'
        ? new Date(metadata.creationTimestamp).toISOString()
        : metadata.creationTimestamp.toISOString()
      : new Date().toISOString(),
    tls: hasTLS,
    status: 'unknown', // This would be populated based on actual status in a real implementation
    labels: metadata.labels || {},
  };
}

/**
 * Transform multiple Kubernetes Ingress objects to IngressData format
 */
export function transformIngresses(k8sIngresses: V1Ingress[]): IngressData[] {
  return k8sIngresses.map(ingress => transformIngress(ingress));
}

/**
 * Filter ingresses based on a search term
 */
export function filterIngresses(ingresses: IngressData[], searchTerm: string): IngressData[] {
  if (!searchTerm) {
    return ingresses;
  }
  
  const term = searchTerm.toLowerCase();
  
  return ingresses.filter(ingress => {
    return (
      ingress.name.toLowerCase().includes(term) ||
      ingress.namespace.toLowerCase().includes(term) ||
      ingress.hosts.some(host => host.toLowerCase().includes(term)) ||
      ingress.urls.some(url => url.toLowerCase().includes(term)) ||
      ingress.paths.some(path => path.toLowerCase().includes(term))
    );
  });
}

/**
 * Extract specific information from ingress annotations
 */
export function getIngressAnnotation(ingress: IngressData, annotationKey: string): string | undefined {
  return ingress.annotations[annotationKey];
}

/**
 * Get the display name for an ingress (using name or first host as fallback)
 */
export function getIngressDisplayName(ingress: IngressData): string {
  if (ingress.name && ingress.name !== 'unknown') {
    return ingress.name;
  }
  return ingress.hosts[0] || ingress.urls[0] || 'Unnamed Ingress';
}

/**
 * Extract all unique labels from ingresses in key:value format, sorted alphabetically
 */
export function getAllLabels(ingresses: IngressData[]): string[] {
  const labelSet = new Set<string>();
  
  for (const ingress of ingresses) {
    if (ingress.labels) {
      for (const [key, value] of Object.entries(ingress.labels)) {
        labelSet.add(`${key}:${value}`);
      }
    }
  }
  
  return Array.from(labelSet).sort();
}

/**
 * Extract all unique annotations from ingresses in key:value format, sorted alphabetically
 */
export function getAllAnnotations(ingresses: IngressData[]): string[] {
  const annotationSet = new Set<string>();
  
  for (const ingress of ingresses) {
    if (ingress.annotations) {
      for (const [key, value] of Object.entries(ingress.annotations)) {
        annotationSet.add(`${key}:${value}`);
      }
    }
  }
  
  return Array.from(annotationSet).sort();
}

/**
 * Filter ingresses based on name/namespace/hosts/paths search term, selected labels, and selected annotations using AND logic
 */
export function filterIngressesAdvanced(
  ingresses: IngressData[], 
  searchTerm: string, 
  selectedLabels: string[],
  selectedAnnotations: string[]
): IngressData[] {
  // If no filters are applied, return all ingresses
  if (!searchTerm && selectedLabels.length === 0 && selectedAnnotations.length === 0) {
    return ingresses;
  }
  
  const term = searchTerm.toLowerCase();
  
  return ingresses.filter(ingress => {
    // Check search term match
    const termMatch = !searchTerm || (
      ingress.name.toLowerCase().includes(term) ||
      ingress.namespace.toLowerCase().includes(term) ||
      ingress.hosts.some(host => host.toLowerCase().includes(term)) ||
      ingress.urls.some(url => url.toLowerCase().includes(term)) ||
      ingress.paths.some(path => path.toLowerCase().includes(term))
    );
    
    // Check if any of the selected labels match (OR logic within labels)
    let hasMatchingLabel = false;
    if (selectedLabels.length > 0 && ingress.labels) {
      for (const selectedLabel of selectedLabels) {
        const [key, value] = selectedLabel.split(':');
        if (ingress.labels[key] && ingress.labels[key] === value) {
          hasMatchingLabel = true;
          break;
        }
      }
    }
    const hasSelectedLabels = selectedLabels.length > 0;
    const labelMatch = hasSelectedLabels ? hasMatchingLabel : true; // If no labels selected, consider it a match
    
    // Check if any of the selected annotations match (OR logic within annotations)
    let hasMatchingAnnotation = false;
    if (selectedAnnotations.length > 0 && ingress.annotations) {
      for (const selectedAnnotation of selectedAnnotations) {
        const [key, value] = selectedAnnotation.split(':');
        if (ingress.annotations[key] && ingress.annotations[key] === value) {
          hasMatchingAnnotation = true;
          break;
        }
      }
    }
    const hasSelectedAnnotations = selectedAnnotations.length > 0;
    const annotationMatch = hasSelectedAnnotations ? hasMatchingAnnotation : true; // If no annotations selected, consider it a match
    
    // Text search must match (AND with label/annotation filter)
    // Between labels and annotations: OR relation (ingress matches if it has selected labels OR selected annotations)
    const labelOrAnnotationMatch = 
      (!hasSelectedLabels && !hasSelectedAnnotations) || // If neither selected, match all
      (hasSelectedLabels && hasSelectedAnnotations && (labelMatch || annotationMatch)) || // Both selected, match if either matches
      (hasSelectedLabels && !hasSelectedAnnotations && labelMatch) || // Only labels selected, match if labels match
      (hasSelectedAnnotations && !hasSelectedLabels && annotationMatch); // Only annotations selected, match if annotations match

    return termMatch && labelOrAnnotationMatch;
  });
}