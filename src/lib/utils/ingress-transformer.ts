import { V1Ingress } from '@kubernetes/client-node';
import { IngressData } from '@/types/ingress';
import { KUBERNETES_NAMESPACE } from '@/constants/kubernetes';
import { generateIngressYAML } from './yaml-generator';

/**
 * Filter out auto-generated annotations that shouldn't be displayed to users
 */
function filterAutoGeneratedAnnotations(
  annotations: Record<string, string> | undefined
): Record<string, string> {
  if (!annotations) return {};

  const filtered: Record<string, string> = {};

  for (const [key, value] of Object.entries(annotations)) {
    // Skip common auto-generated annotations
    if (
      key.startsWith('kubectl.kubernetes.io/') ||
      key.startsWith('deployment.kubernetes.io/') ||
      key.startsWith('replicaset.kubernetes.io/') ||
      key.startsWith('statefulset.kubernetes.io/') ||
      key.startsWith('controller-uid') ||
      key.startsWith('meta.helm.sh/') ||
      key.startsWith('helm.sh/') ||
      key === 'kubernetes.io/ingress.class' // This is often auto-set
    ) {
      continue;
    }
    filtered[key] = value;
  }

  return filtered;
}

/**
 * Transform a raw Kubernetes Ingress object to our UI-friendly IngressData format
 */
export function transformIngress(k8sIngress: V1Ingress): IngressData {
  const metadata = k8sIngress.metadata || {
    name: 'unknown',
    namespace: KUBERNETES_NAMESPACE.DEFAULT,
  };

  const hosts: string[] = [];
  const paths: string[] = [];
  const urls: string[] = [];

  // Extract hosts and paths from ingress rules
  // Ingress rules define how traffic is routed based on host and path
  if (k8sIngress.spec?.rules) {
    for (const rule of k8sIngress.spec.rules) {
      // Collect all unique hosts defined in the ingress
      if (rule.host) {
        hosts.push(rule.host);
      }

      // Extract paths and build complete URLs for each rule
      if (rule.http?.paths) {
        for (const path of rule.http.paths) {
          paths.push(path.path || '/');

          // Build complete URLs combining protocol, host, and path
          // Protocol is determined by TLS configuration
          if (rule.host) {
            const protocol = k8sIngress.spec?.tls ? 'https' : 'http';
            const pathValue = path.path || '/';
            urls.push(`${protocol}://${rule.host}${pathValue}`);
          }
        }
      }
    }
  }

  // Check for TLS configuration to determine if ingress uses HTTPS
  const hasTLS = !!(k8sIngress.spec?.tls && k8sIngress.spec.tls.length > 0);

  // Extract additional hosts from TLS configuration
  // TLS section may define hosts not present in rules
  if (k8sIngress.spec?.tls) {
    for (const tls of k8sIngress.spec.tls) {
      if (tls.hosts) {
        for (const host of tls.hosts) {
          // Only add if not already in hosts array to avoid duplicates
          if (!hosts.includes(host)) {
            hosts.push(host);
          }
        }
      }
    }
  }

  // Generate YAML manifest for the ingress
  let yamlManifest: string | undefined;
  try {
    yamlManifest = generateIngressYAML(k8sIngress);
  } catch (error) {
    console.error('Failed to generate YAML manifest for ingress:', metadata.name, error);
    // Continue without YAML manifest if generation fails
  }

  return {
    id: metadata.uid || `${metadata.namespace}-${metadata.name}`,
    name: metadata.name || 'unknown',
    namespace: metadata.namespace || KUBERNETES_NAMESPACE.DEFAULT,
    hosts,
    paths,
    urls,
    annotations: filterAutoGeneratedAnnotations(metadata.annotations),
    // Handle both string and Date object formats for creationTimestamp
    // Kubernetes API may return either depending on the client library version
    creationTimestamp: metadata.creationTimestamp
      ? typeof metadata.creationTimestamp === 'string'
        ? new Date(metadata.creationTimestamp).toISOString()
        : metadata.creationTimestamp.toISOString()
      : new Date().toISOString(),
    tls: hasTLS,
    status: 'unknown', // This would be populated based on actual status in a real implementation
    labels: metadata.labels || {},
    yamlManifest,
  };
}

/**
 * Transform multiple Kubernetes Ingress objects to IngressData format
 */
export function transformIngresses(k8sIngresses: V1Ingress[]): IngressData[] {
  return k8sIngresses.map((ingress) => transformIngress(ingress));
}

/**
 * Filter ingresses based on a search term
 */
export function filterIngresses(ingresses: IngressData[], searchTerm: string): IngressData[] {
  if (!searchTerm) {
    return ingresses;
  }

  const term = searchTerm.toLowerCase();

  return ingresses.filter((ingress) => {
    return (
      ingress.name.toLowerCase().includes(term) ||
      ingress.namespace.toLowerCase().includes(term) ||
      ingress.hosts.some((host) => host.toLowerCase().includes(term)) ||
      ingress.urls.some((url) => url.toLowerCase().includes(term)) ||
      ingress.paths.some((path) => path.toLowerCase().includes(term))
    );
  });
}

/**
 * Extract specific information from ingress annotations
 */
export function getIngressAnnotation(
  ingress: IngressData,
  annotationKey: string
): string | undefined {
  return ingress.annotations[annotationKey];
}

/**
 * Get the display name for an ingress (using name or first host as fallback)
 */
export function getIngressDisplayName(ingress: IngressData): string {
  if (ingress.name && ingress.name !== 'unknown') {
    return ingress.name;
  }
  return ingress.hosts[0] || ingress.urls[0] || 'Unnamed Ingress';
}

/**
 * Extract all unique labels from ingresses in key:value format, sorted alphabetically
 */
export function getAllLabels(ingresses: IngressData[]): string[] {
  const labelSet = new Set<string>();

  for (const ingress of ingresses) {
    if (ingress.labels) {
      for (const [key, value] of Object.entries(ingress.labels)) {
        labelSet.add(`${key}:${value}`);
      }
    }
  }

  return Array.from(labelSet).sort();
}

/**
 * Extract all unique annotations from ingresses in key:value format, sorted alphabetically
 */
export function getAllAnnotations(ingresses: IngressData[]): string[] {
  const annotationSet = new Set<string>();

  for (const ingress of ingresses) {
    if (ingress.annotations) {
      for (const [key, value] of Object.entries(ingress.annotations)) {
        annotationSet.add(`${key}:${value}`);
      }
    }
  }

  return Array.from(annotationSet).sort();
}

/**
 * Filter ingresses based on name/namespace/hosts/paths search term, selected labels, and selected annotations using AND logic
 */
export function filterIngressesAdvanced(
  ingresses: IngressData[],
  searchTerm: string,
  selectedLabels: string[],
  selectedAnnotations: string[]
): IngressData[] {
  // Early return optimization: If no filters are applied, return all ingresses
  // This avoids unnecessary iteration and filtering logic
  if (!searchTerm && selectedLabels.length === 0 && selectedAnnotations.length === 0) {
    return ingresses;
  }

  const term = searchTerm.toLowerCase();

  return ingresses.filter((ingress) => {
    // Check if ingress matches the text search term
    // Searches across name, namespace, hosts, URLs, and paths
    // Empty search term matches all ingresses
    const termMatch =
      !searchTerm ||
      ingress.name.toLowerCase().includes(term) ||
      ingress.namespace.toLowerCase().includes(term) ||
      ingress.hosts.some((host) => host.toLowerCase().includes(term)) ||
      ingress.urls.some((url) => url.toLowerCase().includes(term)) ||
      ingress.paths.some((path) => path.toLowerCase().includes(term));

    // Check if ingress has any of the selected labels (OR logic within labels)
    // Example: If user selects "app:frontend" OR "env:prod", ingress matches if it has either
    let hasMatchingLabel = false;
    if (selectedLabels.length > 0 && ingress.labels) {
      for (const selectedLabel of selectedLabels) {
        // Parse label in "key:value" format
        const [key, value] = selectedLabel.split(':');
        if (ingress.labels[key] && ingress.labels[key] === value) {
          hasMatchingLabel = true;
          break; // Found a match, no need to check remaining labels
        }
      }
    }
    const hasSelectedLabels = selectedLabels.length > 0;
    const labelMatch = hasSelectedLabels ? hasMatchingLabel : true; // If no labels selected, consider it a match

    // Check if ingress has any of the selected annotations (OR logic within annotations)
    // Example: If user selects "nginx.ingress.kubernetes.io/ssl-redirect:true" OR "cert-manager.io/cluster-issuer:letsencrypt"
    let hasMatchingAnnotation = false;
    if (selectedAnnotations.length > 0 && ingress.annotations) {
      for (const selectedAnnotation of selectedAnnotations) {
        // Parse annotation in "key:value" format
        const [key, value] = selectedAnnotation.split(':');
        if (ingress.annotations[key] && ingress.annotations[key] === value) {
          hasMatchingAnnotation = true;
          break; // Found a match, no need to check remaining annotations
        }
      }
    }
    const hasSelectedAnnotations = selectedAnnotations.length > 0;
    const annotationMatch = hasSelectedAnnotations ? hasMatchingAnnotation : true; // If no annotations selected, consider it a match

    // Complex filtering logic:
    // - Text search must match (AND with label/annotation filter)
    // - Between labels and annotations: OR relation (ingress matches if it has selected labels OR selected annotations)
    // This allows flexible filtering: "Show me ingresses with 'frontend' in the name AND (has label 'app:web' OR annotation 'ssl:enabled')"
    const labelOrAnnotationMatch =
      (!hasSelectedLabels && !hasSelectedAnnotations) || // If neither selected, match all
      (hasSelectedLabels && hasSelectedAnnotations && (labelMatch || annotationMatch)) || // Both selected, match if either matches
      (hasSelectedLabels && !hasSelectedAnnotations && labelMatch) || // Only labels selected, match if labels match
      (hasSelectedAnnotations && !hasSelectedLabels && annotationMatch); // Only annotations selected, match if annotations match

    // Final result: Text search AND (label OR annotation match)
    return termMatch && labelOrAnnotationMatch;
  });
}
